{% extends "base.html" %}

{% block title %}Add Practice{% endblock %}

{% block content %}
<style>
.compact-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
    gap: 0.9rem;
}

.compact-grid.three {
    grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
}

.compact-grid .form-group input,
.compact-grid .form-group select {
    padding: 0.4rem 0.5rem;
    font-size: 0.9rem;
}

.text-toolbar {
    display: flex;
    gap: 0.4rem;
    margin-bottom: 0.4rem;
}

.format-btn {
    padding: 0.25rem 0.5rem;
    border: 1px solid #cbd5e0;
    border-radius: 4px;
    background: #f8f9fa;
    cursor: pointer;
    font-size: 0.85rem;
    min-width: 2.2rem;
}

.format-btn:hover {
    background: #e2e8f0;
}

.rich-text-editor {
    min-height: 140px;
    border: 1px solid #cbd5e0;
    border-radius: 6px;
    padding: 0.65rem;
    font-size: 0.95rem;
    line-height: 1.5;
    background: white;
}

.rich-text-editor:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.15);
}
</style>

<h2>Add New Practice</h2>

<form method="POST" enctype="multipart/form-data" style="max-width: 900px;">
    <div class="compact-grid" style="margin-bottom: 1.25rem;">
        <div class="form-group">
            <label for="practice_sanskrit">Sanskrit Name</label>
            <input type="text" id="practice_sanskrit" name="practice_sanskrit" 
                   placeholder="e.g., Shavasana" autocomplete="off">
            <div id="autocomplete-results" style="position: relative;"></div>
        </div>
        
        <div class="form-group">
            <label for="practice_english">English Name *</label>
            <input type="text" id="practice_english" name="practice_english" required
                   placeholder="e.g., Corpse pose">
        </div>
        
        <div class="form-group">
            <label for="code">Practice Code</label>
            <input type="text" id="code" name="code" 
                   placeholder="e.g., SHA01 (auto-filled)" maxlength="50" autocomplete="off">
            <div id="code-validation-message" style="margin-top: 0.3rem; font-size: 0.85rem;"></div>
            <small style="color: #666; display: block; margin-top: 0.3rem; font-size: 0.85rem;">
                Code for this practice. Same code is used for practices with the same Sanskrit name.
            </small>
        </div>
    </div>
    
    <div class="compact-grid three" style="margin-bottom: 1.25rem;">
        <div class="form-group">
            <label for="practice_segment">Category *</label>
            <select id="practice_segment" name="practice_segment" required>
                <option value="">Select Category</option>
                <option value="Preparatory practices">Preparatory practices</option>
                <option value="Breathing practices">Breathing practices</option>
                <option value="Sequential yogic practices">Sequential yogic practices</option>
                <option value="Yogasana">Yogasana</option>
                <option value="Pranayama">Pranayama</option>
                <option value="Meditation">Meditation</option>
                <option value="Chanting">Chanting</option>
                <option value="Additional practices">Additional practices</option>
                <option value="Kriya (cleansing)">Kriya (cleansing)</option>
                <option value="Yogic counselling">Yogic counselling</option>
                <option value="Relaxation">Relaxation</option>
                <option value="Lifestyle modifications">Lifestyle modifications</option>
                <option value="Yogic diet">Yogic diet</option>
                <option value="Chair Yoga">Chair Yoga</option>
            </select>
        </div>
        
        <div class="form-group">
            <label for="sub_category">Sub-Category</label>
            <input type="text" id="sub_category" name="sub_category" 
                   placeholder="e.g., standing_asana, pranayama_practices">
        </div>
        <div class="form-group">
            <label for="kosha">Kosha *</label>
            <select id="kosha" name="kosha" required>
                <option value="">Select Kosha</option>
                <option value="Annamaya Kosha">Annamaya Kosha</option>
                <option value="Pranamaya Kosha">Pranamaya Kosha</option>
                <option value="Manomaya Kosha">Manomaya Kosha</option>
                <option value="Vijnanamaya Kosha">Vijnanamaya Kosha</option>
                <option value="Anandamaya Kosha">Anandamaya Kosha</option>
            </select>
        </div>
    </div>
    
    <div class="compact-grid three" style="margin-bottom: 1.25rem;">
        <div class="form-group">
            <label for="rounds">Rounds</label>
            <input type="number" id="rounds" name="rounds" placeholder="e.g., 5">
        </div>
        
        <div class="form-group">
            <label for="time_minutes">Duration (minutes)</label>
            <input type="number" step="0.5" id="time_minutes" name="time_minutes" placeholder="e.g., 2">
        </div>
        
        <div class="form-group">
            <label for="strokes_per_min">Strokes</label>
            <input type="number" id="strokes_per_min" name="strokes_per_min" placeholder="If applicable">
        </div>
    </div>

    <div class="form-group">
        <label>Description</label>
        <div class="text-toolbar">
            <button type="button" class="format-btn" data-target="description-editor" data-format="bold"><strong>B</strong></button>
            <button type="button" class="format-btn" data-target="description-editor" data-format="italic"><em>I</em></button>
            <button type="button" class="format-btn" data-target="description-editor" data-format="underline"><span style="text-decoration: underline;">U</span></button>
        </div>
        <div id="description-editor" class="rich-text-editor" contenteditable="true" data-hidden-input="description" placeholder="Brief description of the practice"></div>
        <input type="hidden" id="description" name="description">
    </div>
    
    <div class="form-group">
        <label>How to do!</label>
        <button type="button" class="btn btn-secondary" onclick="addVariationField()" style="margin-bottom: 1rem;">Add Variation</button>
        <div id="variations-container"></div>
    </div>
    
    <div style="padding: 1.5rem; background: #f8f9fa; border-radius: 8px; margin-bottom: 2rem;">
        <h4 style="margin-bottom: 1rem;">Media Attachments</h4>
        
        <div class="form-group">
            <label for="photo">Attach Photo</label>
            <input type="file" id="photo" name="photo" accept="image/*">
        </div>
        
        <div class="form-group">
            <label for="video">Attach Video</label>
            <input type="file" id="video" name="video" accept="video/*">
        </div>
    </div>
    
    <div style="display: flex; gap: 1rem;">
        <button type="submit" class="btn">Add Practice</button>
        <a href="/practices" class="btn btn-secondary">Cancel</a>
    </div>
</form>

<script>
const descriptionEditor = document.getElementById('description-editor');
const descriptionHiddenInput = document.getElementById('description');

function initializeRichTextEditor(editor, hiddenInput, initialHtml = '') {
    if (!editor || !hiddenInput) return;
    editor.innerHTML = initialHtml || editor.innerHTML || '';
    editor.dataset.hiddenInput = hiddenInput.id;
    hiddenInput.value = editor.innerHTML.trim();
    editor.addEventListener('input', () => syncEditorValue(editor));
}

function syncEditorValue(editor) {
    if (!editor) return;
    const hiddenId = editor.dataset.hiddenInput;
    if (!hiddenId) return;
    const hiddenInput = document.getElementById(hiddenId);
    if (hiddenInput) {
        hiddenInput.value = editor.innerHTML.trim();
    }
}

initializeRichTextEditor(descriptionEditor, descriptionHiddenInput);

let variationCount = 0;
const variationsContainer = document.getElementById('variations-container');

function addVariationField(prefillHtml = '', prefillRef = '') {
    if (!variationsContainer) return;
    variationCount++;
    const editorId = `variation_editor_${variationCount}`;
    const hiddenId = `variation_hidden_${variationCount}`;
    const refId = `variation_ref_${variationCount}`;

    const row = document.createElement('div');
    row.className = 'variation-row';
    row.id = `variation-${variationCount}`;
    row.style.display = 'grid';
    row.style.gridTemplateColumns = '2fr 1fr';
    row.style.gap = '1rem';
    row.style.marginBottom = '1rem';
    row.innerHTML = `
        <div>
            <div class="text-toolbar">
                <button type="button" class="format-btn" data-target="${editorId}" data-format="bold"><strong>B</strong></button>
                <button type="button" class="format-btn" data-target="${editorId}" data-format="italic"><em>I</em></button>
                <button type="button" class="format-btn" data-target="${editorId}" data-format="underline"><span style="text-decoration: underline;">U</span></button>
            </div>
            <div id="${editorId}" class="rich-text-editor" contenteditable="true" data-hidden-input="${hiddenId}"></div>
            <input type="hidden" id="${hiddenId}" name="variation_${variationCount}">
        </div>
        <div>
            <input type="text" id="${refId}" name="variation_ref_${variationCount}" 
                   placeholder="Referred in (paper/book)">
            <button type="button" class="btn btn-secondary remove-variation-btn" data-variation-index="${variationCount}"
                    style="margin-left: 0.5rem; margin-top: 0.5rem;">Remove</button>
        </div>
    `;
    variationsContainer.appendChild(row);

    const editor = document.getElementById(editorId);
    const hiddenInput = document.getElementById(hiddenId);
    initializeRichTextEditor(editor, hiddenInput, prefillHtml);
    if (prefillRef) {
        document.getElementById(refId).value = prefillRef;
    }
}

function reindexVariations() {
    if (!variationsContainer) return;
    const rows = variationsContainer.querySelectorAll('.variation-row');
    variationCount = rows.length;
    rows.forEach((row, index) => {
        const newIndex = index + 1;
        row.id = `variation-${newIndex}`;

        const editor = row.querySelector('.rich-text-editor');
        const hiddenInput = row.querySelector('input[type="hidden"]');
        const refInput = row.querySelector('input[id^="variation_ref_"]');
        const toolbarButtons = row.querySelectorAll('.format-btn');

        if (editor && hiddenInput) {
            const editorId = `variation_editor_${newIndex}`;
            const hiddenId = `variation_hidden_${newIndex}`;
            editor.id = editorId;
            editor.dataset.hiddenInput = hiddenId;
            hiddenInput.id = hiddenId;
            hiddenInput.name = `variation_${newIndex}`;
            syncEditorValue(editor);
            toolbarButtons.forEach(btn => btn.dataset.target = editorId);
        }

        if (refInput) {
            refInput.id = `variation_ref_${newIndex}`;
            refInput.name = `variation_ref_${newIndex}`;
        }

        const removeBtn = row.querySelector('.remove-variation-btn');
        if (removeBtn) {
            removeBtn.dataset.variationIndex = newIndex;
        }
    });
}

function syncAllVariationEditors() {
    if (!variationsContainer) return;
    variationsContainer.querySelectorAll('.rich-text-editor').forEach(editor => syncEditorValue(editor));
}

document.addEventListener('click', (event) => {
    const removeBtn = event.target.closest('.remove-variation-btn');
    if (removeBtn) {
        event.preventDefault();
        const row = removeBtn.closest('.variation-row');
        if (row) {
            row.remove();
            reindexVariations();
        }
        return;
    }

    const formatBtn = event.target.closest('.format-btn');
    if (!formatBtn) return;

    event.preventDefault();
    const editor = document.getElementById(formatBtn.dataset.target);
    if (!editor) return;
    editor.focus();
    document.execCommand(formatBtn.dataset.format, false, null);
    syncEditorValue(editor);
});

const practiceForm = document.querySelector('form');
if (practiceForm) {
    practiceForm.addEventListener('submit', () => {
        syncEditorValue(descriptionEditor);
        syncAllVariationEditors();
    });
}

// Category to Kosha mapping (supports legacy labels)
const categoryToKosha = {
    'Preparatory practices': 'Annamaya Kosha',
    'Preparatory Practice': 'Annamaya Kosha',
    'Yogasana': 'Annamaya Kosha',
    'Kriya (cleansing)': 'Annamaya Kosha',
    'Kriya (Cleansing Techniques)': 'Annamaya Kosha',
    'Sequential yogic practices': 'Annamaya Kosha',
    'Sequential Yogic Practice': 'Annamaya Kosha',
    'Lifestyle modifications': 'Annamaya Kosha',
    'Lifestyle modifications (Anna)': 'Annamaya Kosha',
    'Yogic diet': 'Annamaya Kosha',
    'Yogic diet (Anna)': 'Annamaya Kosha',
    'Chair Yoga': 'Annamaya Kosha',
    'Chair Yoga (Anna)': 'Annamaya Kosha',
    'Breathing practices': 'Pranamaya Kosha',
    'Breathing Practice': 'Pranamaya Kosha',
    'Pranayama': 'Pranamaya Kosha',
    'Relaxation': 'Annamaya Kosha',
    'Meditation': 'Manomaya Kosha',
    'Chanting': 'Manomaya Kosha',
    'Yogic counselling': 'Vijnanamaya Kosha',
    'Yogic Counselling': 'Vijnanamaya Kosha',
    'Additional practices': '',
    'Additional Practices': ''
};

// Auto-fill Kosha based on Category selection
const categorySelect = document.getElementById('practice_segment');
const koshaSelect = document.getElementById('kosha');

if (categorySelect && koshaSelect) {
    categorySelect.addEventListener('change', function() {
        const selectedCategory = this.value;
        const mappedKosha = categoryToKosha[selectedCategory];
        if (mappedKosha) {
            koshaSelect.value = mappedKosha;
        }
    });
}

// Autocomplete functionality for Sanskrit name
let autocompleteTimeout;
let currentPractices = [];
let selectedIndex = -1;
const sanskritInput = document.getElementById('practice_sanskrit');
const autocompleteDiv = document.getElementById('autocomplete-results');

sanskritInput.addEventListener('input', function() {
    clearTimeout(autocompleteTimeout);
    const query = this.value.trim();
    selectedIndex = -1;
    
    if (query.length < 1) {
        autocompleteDiv.innerHTML = '';
        currentPractices = [];
        return;
    }
    
    autocompleteTimeout = setTimeout(() => {
        fetch(`/api/practice/search?q=${encodeURIComponent(query)}`)
            .then(response => response.json())
            .then(data => {
                currentPractices = data;
                displayAutocompleteResults(data);
            });
    }, 300);
});

// Keyboard navigation
sanskritInput.addEventListener('keydown', function(e) {
    if (autocompleteDiv.innerHTML === '') return;
    
    const items = autocompleteDiv.querySelectorAll('.autocomplete-item');
    
    switch(e.key) {
        case 'ArrowDown':
            e.preventDefault();
            selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
            updateSelection();
            break;
        case 'ArrowUp':
            e.preventDefault();
            selectedIndex = Math.max(selectedIndex - 1, -1);
            updateSelection();
            break;
        case 'Enter':
            e.preventDefault();
            if (selectedIndex >= 0 && selectedIndex < items.length) {
                selectPractice(currentPractices[selectedIndex].id);
            }
            break;
        case 'Escape':
            autocompleteDiv.innerHTML = '';
            currentPractices = [];
            selectedIndex = -1;
            break;
    }
});

function updateSelection() {
    const items = autocompleteDiv.querySelectorAll('.autocomplete-item');
    items.forEach((item, index) => {
        if (index === selectedIndex) {
            item.style.backgroundColor = '#e3f2fd';
            item.style.borderLeft = '3px solid #2196f3';
        } else {
            item.style.backgroundColor = '';
            item.style.borderLeft = '';
        }
    });
}

function displayAutocompleteResults(practices) {
    if (practices.length === 0) {
        autocompleteDiv.innerHTML = '';
        return;
    }
    
    autocompleteDiv.innerHTML = '<div style="background: white; border: 1px solid #ddd; border-radius: 5px; max-height: 300px; overflow-y: auto; box-shadow: 0 2px 10px rgba(0,0,0,0.1); position: absolute; width: 100%; z-index: 1000;">' +
        practices.map((p, index) => `
            <div class="autocomplete-item" style="padding: 0.7rem; cursor: pointer; border-bottom: 1px solid #eee;" 
                 onclick="event.stopPropagation(); selectPractice(${p.id});" data-index="${index}">
                <strong>${p.practice_sanskrit || 'No Sanskrit name'}</strong><br>
                <small>${p.practice_english}</small>
            </div>
        `).join('') +
        '</div>';
}

function selectPractice(id) {
    const practice = currentPractices.find(p => p.id === id);
    if (practice) {
        // Close autocomplete immediately to prevent any visual issues
        autocompleteDiv.innerHTML = '';
        currentPractices = [];
        selectedIndex = -1;
        
        // Fill all fields except media attachments
        document.getElementById('practice_sanskrit').value = practice.practice_sanskrit || '';
        document.getElementById('practice_english').value = practice.practice_english;
        
        // Fill Code
        const codeField = document.getElementById('code');
        if (codeField && practice.code) {
            codeField.value = practice.code;
        }
        
        // Clear validation message after autofill
        const validationMessageDiv = document.getElementById('code-validation-message');
        if (validationMessageDiv) {
            validationMessageDiv.innerHTML = '';
            validationMessageDiv.style.display = 'none';
        }
        
        // Fill Category (practice_segment)
        const practiceSegmentField = document.getElementById('practice_segment');
        if (practiceSegmentField && practice.practice_segment) {
            practiceSegmentField.value = practice.practice_segment;
        }
        
        // Fill Kosha
        const koshaField = document.getElementById('kosha');
        if (koshaField && practice.kosha) {
            koshaField.value = practice.kosha;
        } else if (koshaField && practiceSegmentField && practice.practice_segment) {
            // Auto-fill kosha based on category if not provided
            const categoryToKosha = {
                'Preparatory practices': 'Annamaya Kosha',
                'Preparatory Practice': 'Annamaya Kosha',
                'Yogasana': 'Annamaya Kosha',
                'Kriya (cleansing)': 'Annamaya Kosha',
                'Kriya (Cleansing Techniques)': 'Annamaya Kosha',
                'Sequential yogic practices': 'Annamaya Kosha',
                'Sequential Yogic Practice': 'Annamaya Kosha',
                'Lifestyle modifications': 'Annamaya Kosha',
                'Lifestyle modifications (Anna)': 'Annamaya Kosha',
                'Yogic diet': 'Annamaya Kosha',
                'Yogic diet (Anna)': 'Annamaya Kosha',
                'Chair Yoga': 'Annamaya Kosha',
                'Chair Yoga (Anna)': 'Annamaya Kosha',
                'Breathing practices': 'Pranamaya Kosha',
                'Breathing Practice': 'Pranamaya Kosha',
                'Pranayama': 'Pranamaya Kosha',
                'Relaxation': 'Annamaya Kosha',
                'Meditation': 'Manomaya Kosha',
                'Chanting': 'Manomaya Kosha',
                'Yogic counselling': 'Vijnanamaya Kosha',
                'Yogic Counselling': 'Vijnanamaya Kosha',
                'Additional practices': '',
                'Additional Practices': ''
            };
            const mappedKosha = categoryToKosha[practice.practice_segment];
            if (mappedKosha) {
                koshaField.value = mappedKosha;
            }
        }
        
        const subCategoryField = document.getElementById('sub_category');
        if (subCategoryField) subCategoryField.value = practice.sub_category || '';
        const roundsField = document.getElementById('rounds');
        if (roundsField) roundsField.value = practice.rounds || '';
        const durationField = document.getElementById('time_minutes');
        if (durationField) durationField.value = practice.time_minutes || '';
        const strokesField = document.getElementById('strokes_per_min');
        if (strokesField) strokesField.value = practice.strokes_per_min || '';
        if (descriptionEditor) {
            descriptionEditor.innerHTML = practice.description || '';
            syncEditorValue(descriptionEditor);
        }
        
        // Clear existing variations first
        const variationsContainer = document.getElementById('variations-container');
        if (variationsContainer) {
            variationsContainer.innerHTML = '';
            variationCount = 0;
            
            // Handle variations
            if (practice.variations) {
                try {
                    const variations = JSON.parse(practice.variations);
                    if (variations && variations.length > 0) {
                        variations.forEach((v) => {
                            const textValue = (typeof v === 'object' && v !== null) ? (v.text || '') : v;
                            const refValue = (typeof v === 'object' && v !== null) ? (v.referred_in || '') : '';
                            addVariationField(textValue, refValue);
                        });
                    }
                } catch (e) {
                    // Old format - simple array
                    try {
                        const variations = typeof practice.variations === 'string' ? JSON.parse(practice.variations) : [];
                        if (variations && variations.length > 0) {
                            variations.forEach((v) => {
                                addVariationField(v, '');
                            });
                        }
                    } catch (e2) {
                        console.error('Error parsing variations:', e2);
                    }
                }
            }
        }
        syncAllVariationEditors();
        
        // Move focus to the next field (English Name)
        document.getElementById('practice_english').focus();
    }
}

        // Close autocomplete when clicking outside
document.addEventListener('click', function(e) {
    if (!e.target.closest('#practice_sanskrit') && !e.target.closest('#autocomplete-results')) {
        autocompleteDiv.innerHTML = '';
        currentPractices = [];
        selectedIndex = -1;
    }
});

// Real-time validation for code/Sanskrit name consistency
let validationTimeout;
const codeInput = document.getElementById('code');
const sanskritNameInput = document.getElementById('practice_sanskrit');
const validationMessageDiv = document.getElementById('code-validation-message');

function validateCodeSanskrit() {
    clearTimeout(validationTimeout);
    const code = (codeInput.value || '').trim();
    const sanskrit = (sanskritNameInput.value || '').trim();
    
    // Clear previous validation message
    validationMessageDiv.innerHTML = '';
    validationMessageDiv.style.display = 'none';
    
    // Only validate if at least one field has content
    if (!code && !sanskrit) {
        return;
    }
    
    // Debounce validation
    validationTimeout = setTimeout(() => {
        fetch(`/api/practice/validate-code-sanskrit?code=${encodeURIComponent(code)}&sanskrit_name=${encodeURIComponent(sanskrit)}`)
            .then(response => response.json())
            .then(data => {
                if (!data.valid && data.message) {
                    // Show validation error
                    validationMessageDiv.innerHTML = `<span style="color: #dc3545;">⚠️ ${data.message}</span>`;
                    validationMessageDiv.style.display = 'block';
                    
                    // If there's a suggested code, auto-fill it (for sanskrit_code_mismatch)
                    if (data.conflict_type === 'sanskrit_code_mismatch' && data.existing_code && codeInput.value !== data.existing_code) {
                        // Don't auto-fill if user is actively typing code
                        // Only auto-fill if code field is empty or was auto-filled
                        if (!codeInput.value || codeInput.value === code) {
                            codeInput.value = data.existing_code;
                            // Re-validate with new code
                            setTimeout(() => validateCodeSanskrit(), 100);
                        }
                    }
                } else {
                    // Clear validation message
                    validationMessageDiv.innerHTML = '';
                    validationMessageDiv.style.display = 'none';
                }
            })
            .catch(error => {
                console.error('Validation error:', error);
            });
    }, 500); // Wait 500ms after user stops typing
}

// Add event listeners for real-time validation
if (codeInput) {
    codeInput.addEventListener('input', validateCodeSanskrit);
    codeInput.addEventListener('blur', validateCodeSanskrit);
}

if (sanskritNameInput) {
    sanskritNameInput.addEventListener('input', validateCodeSanskrit);
    sanskritNameInput.addEventListener('blur', validateCodeSanskrit);
}

</script>

<style>
.autocomplete-item:hover {
    background: #f0f0f0;
}
</style>
{% endblock %}
